#!/usr/bin/env python3
"""
Investment Ideas API

This script runs a FastAPI server that serves the generated investment ideas.
"""

import os
import json
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv

from fastapi import FastAPI, HTTPException, Query, Depends, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# Import cloud functions
try:
    from .cloud_functions import (
        load_investment_ideas_from_cloud,
        get_available_dates_from_cloud,
        update_investment_data,
        is_running_on_cloud
    )
except ImportError:
    # Direct import if relative import fails
    from cloud_functions import (
        load_investment_ideas_from_cloud,
        get_available_dates_from_cloud,
        update_investment_data,
        is_running_on_cloud
    )

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=os.getenv("LOG_LEVEL", "INFO"),
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Set up paths
DATA_DIR = Path(__file__).parent.parent / "data"
PROCESSED_DATA_DIR = DATA_DIR / "processed"

# Create FastAPI app
app = FastAPI(
    title="ALLMBA Investment Ideas API",
    description="API for accessing daily investment ideas generated by ALLMBA",
    version="1.0.0",
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins for now
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Define models
class Metrics(BaseModel):
    return_pct: Optional[float] = None
    volatility: Optional[float] = None
    rsi: Optional[float] = None
    sentiment: Optional[float] = None
    yield_change: Optional[float] = None
    price: Optional[float] = None
    article_count: Optional[int] = None

class InvestmentIdea(BaseModel):
    id: str
    title: str
    type: str
    asset: str
    rationale: str
    risk_level: str
    time_horizon: str
    sector: Optional[str] = None
    market: Optional[str] = None
    direction: Optional[str] = None
    metrics: Dict[str, Any]
    date: str

class InvestmentIdeasResponse(BaseModel):
    date: str
    ideas: List[InvestmentIdea]
    count: int

# Function to load investment ideas
def load_investment_ideas(date: Optional[str] = None) -> dict:
    """
    Load investment ideas from processed data directory or cloud storage.
    
    Args:
        date (str, optional): Date string in YYYY-MM-DD format. If None, the latest file is used.
    
    Returns:
        dict: Dictionary containing investment ideas
    """
    # Try loading from cloud storage first if we're running on GCP
    if is_running_on_cloud():
        cloud_data = load_investment_ideas_from_cloud(date)
        if cloud_data:
            return cloud_data
    
    # Fall back to local storage
    try:
        if date:
            # Find file for the specific date
            file_path = PROCESSED_DATA_DIR / f"investment_ideas_{date}.json"
            if not file_path.exists():
                return None
        else:
            # Find the latest file
            files = sorted(PROCESSED_DATA_DIR.glob("investment_ideas_*.json"), reverse=True)
            if not files:
                return None
            file_path = files[0]
        
        with open(file_path, 'r') as f:
            data = json.load(f)
            
            # Add ID field to each idea
            for i, idea in enumerate(data.get("ideas", [])):
                idea["id"] = f"{data.get('date', 'unknown')}-{i+1}"
            
            return data
    except Exception as e:
        logger.error(f"Error loading investment ideas: {e}")
        return None

# Define routes
@app.get("/", response_model=dict)
def read_root():
    return {"message": "Welcome to ALLMBA Investment Ideas API"}

@app.get("/api/ideas", response_model=InvestmentIdeasResponse)
def get_investment_ideas(
    date: Optional[str] = Query(None, description="Date in YYYY-MM-DD format"),
    type: Optional[str] = Query(None, description="Filter by idea type"),
    risk_level: Optional[str] = Query(None, description="Filter by risk level"),
):
    # Load ideas
    ideas_data = load_investment_ideas(date)
    
    if not ideas_data:
        if date:
            raise HTTPException(status_code=404, detail=f"No investment ideas found for date {date}")
        else:
            raise HTTPException(status_code=404, detail=f"No investment ideas found")
    
    ideas = ideas_data.get("ideas", [])
    result_date = ideas_data.get("date", datetime.now().strftime("%Y-%m-%d"))
    
    # Apply filters
    if type:
        ideas = [idea for idea in ideas if idea.get("type") == type]
    
    if risk_level:
        ideas = [idea for idea in ideas if idea.get("risk_level") == risk_level]
    
    # Add date to each idea if not present
    for idea in ideas:
        if "date" not in idea:
            idea["date"] = result_date
    
    return {
        "date": result_date,
        "ideas": ideas,
        "count": len(ideas)
    }

@app.get("/api/ideas/{idea_id}", response_model=InvestmentIdea)
def get_investment_idea(idea_id: str):
    # Parse date from idea_id
    try:
        date = idea_id.split('-')[0]
        ideas_data = load_investment_ideas(date)
        
        if not ideas_data:
            raise HTTPException(status_code=404, detail=f"No investment ideas found for ID {idea_id}")
        
        # Find the idea with the matching ID
        for idea in ideas_data.get("ideas", []):
            if idea.get("id") == idea_id:
                if "date" not in idea:
                    idea["date"] = ideas_data.get("date", datetime.now().strftime("%Y-%m-%d"))
                return idea
        
        raise HTTPException(status_code=404, detail=f"Investment idea with ID {idea_id} not found")
    except Exception as e:
        logger.error(f"Error retrieving investment idea: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving investment idea")

@app.get("/api/dates", response_model=List[str])
def get_available_dates():
    """
    Get a list of dates for which investment ideas are available.
    """
    try:
        # Try to get dates from cloud storage first
        if is_running_on_cloud():
            cloud_dates = get_available_dates_from_cloud()
            if cloud_dates:
                return cloud_dates
        
        # Fall back to local storage
        files = sorted(PROCESSED_DATA_DIR.glob("investment_ideas_*.json"), reverse=True)
        dates = []
        
        for file in files:
            try:
                date = file.stem.replace("investment_ideas_", "")
                dates.append(date)
            except Exception:
                pass
        
        return dates
    except Exception as e:
        logger.error(f"Error retrieving available dates: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving available dates")

@app.get("/api/types", response_model=List[str])
def get_idea_types():
    """
    Get a list of all available investment idea types.
    """
    try:
        ideas_data = load_investment_ideas()
        if not ideas_data:
            return []
        
        ideas = ideas_data.get("ideas", [])
        types = set(idea.get("type") for idea in ideas if "type" in idea)
        
        return sorted(list(types))
    except Exception as e:
        logger.error(f"Error retrieving idea types: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving idea types")


@app.post("/api/tasks/update", response_model=Dict[str, Any])
async def update_data(background_tasks: BackgroundTasks):
    """
    Trigger a background task to update investment data.
    This endpoint is designed to be called by a scheduler to update data daily.
    """
    # Add the update task to background tasks
    background_tasks.add_task(update_investment_data)
    
    return {
        "status": "success", 
        "message": "Data update task started", 
        "timestamp": datetime.now().isoformat()
    }


if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("API_PORT", 8080))
    uvicorn.run("api:app", host="0.0.0.0", port=port, reload=True)
